% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/history.R
\name{undoHistory}
\alias{undoHistory}
\alias{undoHistoryUI}
\alias{undoHistoryUI_debug}
\alias{undoHistoryDemo}
\title{Undo/Redo History Buttons}
\usage{
undoHistory(id, value, value_debounce_rate = 500)

undoHistoryUI(id, class = NULL, btn_class = "btn btn-default",
  back_text = NULL, back_title = "Undo", back_icon = "undo",
  fwd_text = NULL, fwd_title = "Redo", fwd_icon = "redo")

undoHistoryUI_debug(id)

undoHistoryDemo(display.mode = c("showcase", "normal", "auto"))
}
\arguments{
\item{id}{The module id}

\item{value}{The reactive expression with the values should be saved for the
user's history. This expression can contain arbitrary data and be of any
structure as long as it returns a single value (or list). Each change in
this value is stored, so the module may not work well for storing large
data sets.}

\item{value_debounce_rate}{Debounce rate in milliseconds for the \code{value}
reactive expression. To avoid saving spurious changes in \code{value}, the
expression is debounced. See \code{\link[shiny:debounce]{shiny::debounce()}} for more information.}

\item{class}{The class applied to the parent button group container that
holds the undo/redo buttons.}

\item{btn_class}{The classes applied to the buttons. Use a single character
vector to apply the same class to both buttons, or a character vector of
length 2 to apply individual classes to each button, (undo/redo
respectively).}

\item{back_text, fwd_text}{The button text}

\item{back_title, fwd_title}{The button title (shown on hover)}

\item{back_icon, fwd_icon}{The icons used for the buttons, passed to
\code{\link[shiny:icon]{shiny::icon()}}. Set to \code{NULL} for no icon. You can also add arbitrary HTML
to \code{back_text} and \code{fwd_text} as the inner HTML of the \code{<button>} element.}

\item{display.mode}{The mode in which to display the application. If set to
the value \code{"showcase"}, shows application code and metadata from a
\code{DESCRIPTION} file in the application directory alongside the
application. If set to \code{"normal"}, displays the application normally.
Defaults to \code{"auto"}, which displays the application in the mode given
in its \code{DESCRIPTION} file, if any.}
}
\description{
This is a simple Shiny module for undo/redo history. The Shiny module accepts
an arbitrary reactive data value. Changes in the state of this reactive value
are tracked and added to the user's history. The user can then repeatedly
undo and redo to walk through this stack. The module returns the current
selected value of the reactive from this historical stack, or \code{NULL} when
the app state was changed by the user. Because this reactive can hold
arbitrary data about the state of the Shiny app, it is up to the app
developer to use the returned current value to update the Shiny apps' inputs
and UI elements.
}
\section{Functions}{
\itemize{
\item \code{undoHistoryUI}: Create the UI elements for the undo/redo buttons

\item \code{undoHistoryUI_debug}: Debug the saved state. This adds a
\code{\link[shiny:verbatimTextOutput]{shiny::verbatimTextOutput()}} UI element that reports the current history
stacks. \code{.$history} contains the historical states that are accessed when
undoing or walking backward and \code{.$future} contains the (psuedo-)future
states to for redo (or walking forward). \code{.$current} contains the current
value that is reported by the \code{undoHistory()} module. Note that this value
will be \code{NULL} when the user is driving the apps state updating.

\item \code{undoHistoryDemo}: Example app demonstrating usage of the history module.
}}

\examples{
\dontrun{
library(shiny)
library(shinyThings)

ui <- fluidPage(
  # Add the Undo/Redo buttons to the UI
  undoHistoryUI("hist", back_text = "Step Backward", fwd_text = "Step Forward"),

  # A simple text input element whose history we'll track
  textInput("text", "Enter your text here"),

  # Debugging elements for the demo
  verbatimTextOutput("v"),
  tags$h4("debug"),
  undoHistoryUI_debug("hist")
)

server <- function(input, output, session) {
  # Use undoHistory() to keep track of the value of input$text
  undo_app_state <- undoHistory(
    id = "hist",
    value = reactive({
      # Value must be a reactive, but can be any structure you want
      req(!is.null(input$text))
      input$text
    })
  )

  # Use an observer to receive updates from undoHistory() and update the app.
  observe({
    req(!is.null(undo_app_state())) #<< Need to update app whenever not NULL

    # Manually update app UI and reactive values
    updateTextInput(session, "text", value = undo_app_state())
  })

  # Just for debugging
  output$v <- renderPrint(input$text)
}

shinyApp(ui, server)
}

}
